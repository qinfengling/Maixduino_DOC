{"./":{"url":"./","title":"Introduction","keywords":"","body":"Maixduino Documentation What is Maixduino Maixduino makes the Arduino IDE and libraries support the Maix series of development boards (k210 chips), making it easy to use a large number of existing open source Arduino libraries for rapid development and prototyping Install Instructions to install Maixduino in the Arduino IDE can be found here Use PlatformIO IDE You can get more powerful support through using PlatformIO IDE. See more "},"others/what_maix_do.html":{"url":"others/what_maix_do.html","title":"What Maix Can Do","keywords":"","body":"What The Powerful Maix Board(k210) Can Do Most of these examples integrate MaixPy, and some of them use Maixduino or code from other developers Draw picture tutorial Openmv and Record video MobileNet Face detection NES game emulator MNIST Play video Feature map display GBA game emulator Game Quake I source code Game Doom source code MMD 3D rendering your browser does not support the video tag source code Gimbal face track Mic array LittlevGL FFT spectrum "},"hardware/k210.html":{"url":"hardware/k210.html","title":"K210","keywords":"","body":"K210 The Kendryte K210 is a system-on-chip (SoC) that integrates machine vision and machine hearing. Using TSMC's ultra-low-power 28nm advanced process with dual-core 64-bit processors for better power, performance, stability and reliability. The program strives for zero threshold development and can be deployed in the user's products in the shortest time, giving the product artificial intelligence. The Kendryte K210 is located in the SoC of the AI ​​and IoT markets and is a very convenient MCU. In Chinese, Kendryte means surveying intelligence, while surveying intelligence is taken from surveying and searching. The main application field of this chip is in the field of Internet of Things, and it is developed in the field of Internet of Things. Therefore, this chip mainly provides artificial intelligence solutions, which are explored in the field. Machine vision Machine hearing Better low power vision processing speed and accuracy With convolutional artificial neural network hardware accelerator KPU, high performance convolution artificial neural network operation TSMC 28nm advanced process, temperature range -40 ° C to 125 ° C, stable and reliable Supports firmware encryption, it is difficult to crack using common methods Unique programmable IO array for more flexible product design Low voltage, lower power consumption compared to systems with the same processing power 3.3V/1.8V dual voltage support, no level shifting, cost saving AI Solution Machine Vision With machine vision capabilities, the Kendryte K210 is a zero-threshold machine vision embedded solution. It can perform convolutional neural network calculations in low power situations. The chip can achieve the following machine vision capabilities: General target detection based on Convolutional Neural Network Image Classification based on Convolutional Neural Network Face detection and face recognition Get the size and coordinates of the detected target in real time Get the type of detected target in real time Machine hearing The Kendryte K210 has machine hearing capabilities. The chip comes with a high-performance microphone array audio processor for real-time source orientation and beamforming. The chip can achieve the following machine hearing capabilities: Sound source orientation Sound field imaging Beamforming Voice wake up Speech Recognition Visual/Hearing Hybrid Solution The Kendryte K210 combines machine vision and machine hearing to provide even more powerful features. On the one hand, in the application, both the sound source localization and the sound field imaging can be used to assist the machine vision to track the target, and the general target detection can be used to obtain the target's orientation, and then the machine hearing aids the beamforming of the orientation. On the other hand, the direction of the person can be obtained by the image transmitted from the camera, so that the microphone array is directed to the person by beamforming. At the same time, the direction of a speaker can be determined according to the microphone array, and the camera is rotated to point to the person. Data download Kendryte official website download page where there is a must-see datasheet Kendryte Github "},"hardware/module.html":{"url":"hardware/module.html","title":"Module","keywords":"","body":"Modules Sipeed M1 (Lichee Dan) "},"hardware/m1.html":{"url":"hardware/m1.html","title":"Sipeed M1","keywords":"","body":"Sipeed M1 (Lichee Dan) M1/M1W M1: K210 full pin lead-out, 8M SRAM built in chip, 16M Flash built in module M1W is with WiFi ( esp8285) version Data download Chip K210 Datasheet: Kendryte Official Website Docs: dl.sipeed.com "},"hardware/board.html":{"url":"hardware/board.html","title":"Board","keywords":"","body":"Boards There are three boards as follows: Dan dock with Sipeed M1(Dan) module Sipeed Maix BiT Sipeed Go "},"hardware/dan_dock.html":{"url":"hardware/dan_dock.html","title":"Dan Dock","keywords":"","body":"Sipeed M1 (Lichee Dan) Dan dock with Sipeed M1(Dan) module Docs: dl.sipeed.com "},"hardware/bit.html":{"url":"hardware/bit.html","title":"BiT","keywords":"","body":"Sipeed Maix BiT Docs: dl.sipeed.com "},"hardware/go.html":{"url":"hardware/go.html","title":"Go","keywords":"","body":"Sipeed Maix Go Docs: dl.sipeed.com "},"hardware/peripheral_modules.html":{"url":"hardware/peripheral_modules.html","title":"Peripheral Modules","keywords":"","body":"Peripheral Modules Microphone array Binocular camera LCD Module "},"hardware/binocular.html":{"url":"hardware/binocular.html","title":"Binocular camera","keywords":"","body":"Binocular camera Buy: Taobao Download： dl.sipeed.com "},"hardware/lcd.html":{"url":"hardware/lcd.html","title":"LCD Module","keywords":"","body":"LCD Module Download: Maix LCD Docs: dl.sipeed.com "},"hardware/mic_array.html":{"url":"hardware/mic_array.html","title":"Microphone array","keywords":"","body":"Microphone array Buy: Taobao Docs: dl.sipeed.com "},"get_started/get_hardware.html":{"url":"get_started/get_hardware.html","title":"Get Hardware","keywords":"","body":"Get development board Get your favorite hardware from Sipeed's official Taobao store： Taobao Required hardware -A development board Choose a board here USB Type C cable Type-C is chosen because it supports positive and negative insertion and is very friendly to development. Buy from official Taobao and ask if it is included, most of the current Android phones are also using Type C cable Screen By default, the LCD (24pin interface) of the st7789 driver chip is used with a resolution of 320x240. Buy from official Taobao and ask if it is included Camera Use ov2640 by default Buy from official Taobao and ask if it is included Micro SD Card (TF Card) (optional) Optional SD card can also manipulate files. Some of the internal Flash has been reserved as a file system, but Flash is very slow! In order to facilitate the quick operation of the picture file, you can choose to purchase a Micro SD card, MaixPy has built-in SPI SD card protocol driver. When purchasing, try to choose a new Micro SD card with fast speed, such as SD 2nd generation protocol, Class10 memory card. Of course, the quality of SD cards on the market is uneven, and the SPI mode may not be compatible. Try to buy a regular card. Or maybe you should customize the driver code ~~ As shown below, the two cards on the left are not supported by the MaixPy driver. Both the middle and the right are supported, but the class10 card in the middle is the fastest. ST-Link (used to update the firmware of the STM32 on the development board Maix Go) (optional) If you purchase Maix Go, it integrates a STM32 chip to simulate the 'USB to serial' tool, and simulate JTAG. If you want to update its firmware later, it is recommended to buy a ST-Link Spare JTAG Debugger (optional) K210 This chip supports JTAG debugging. If you need debugging function, you need to use JTAG debugger. Please consult the official Sipeed Taobao shop. If you are using a Maix Go development board, you don't need to purchase the JTAG debugger separately. The Max Go development board has an integrated STM32 chip that can emulate JTAG (STM32 uses CMSIS-DAP or open-ec firmware), open-ec firmware is not currently supported, but will be supported later, please refer to the open-ec github project home page description "},"get_started/install.html":{"url":"get_started/install.html","title":"Install","keywords":"","body":"Install Arduino Environment Linux Download Arduino IDE The Arduino IDE can be found on the official download page Install dependencies For Ubuntu, enter the following commands in a terminal: sudo usermod -a -G dialout $(whoami) sudo apt install python3 python3-pip sudo pip3 install pyserial Note that after setting the dialout group you need to logout or reboot , else the new settings won't take effect! Add board in Arduino IDE Add URLs Open Arduino IDE, select File -> Preferences, Add one of the folowing URLs in Additional Boards Manager URLs, if there already are board manager URLs do not forget to separate them with a comma. http://dl.sipeed.com/MAIX/Maixduino/package_Maixduino_k210_index.json or try this URL if the download speed is too slow: http://dl.sipeed.com/MAIX/Maixduino/package_Maixduino_k210_dl_cdn_index.json Install board tools and libs Select Tools -> Board -> Boards Manager， search for Maixduino, select the latest version, and click Install Change settings about board Change board settings in Tools section on the top of Arduino IDE. Board: Choose your dev board Burn Tool Firmware: just for Maix Go Board, default open-ec Burn Baudrate: Decrease the baudrate if the download fails Port: Serial port, e.g. /dev/ttyUSB0 Programmer: Burn tool, you MUST select k-flash Windows Download Arduino IDE official download page Then double click pack to install Add board in Arduino IDE Add URLs Open Arduino IDE, select File -> Preferences, Add Additional Boards Manager URLs: http://dl.sipeed.com/MAIX/Maixduino/package_Maixduino_k210_index.json (Recommended) or http://dl.sipeed.com/MAIX/Maixduino/package_Maixduino_k210_dl_cdn_index.json (if download fails or the speed is too low, try this URL) Install board tools and libs Select Tools -> Board -> Boards Manager， search Maixduino, click Install Change settings about board Change board settings in Tools section on the top of Arduino IDE. Board: The same as your dev board Burn Toolfirmware: just for Maix Go Board, default open-ec Burn Baudrate: Decrease it if download fails Port: Serial port, e.g. /dev/ttyUSB0 Programmer: Burn tool, you MUST select k-flash "},"cores/analog.html":{"url":"cores/analog.html","title":"Analog I/O","keywords":"","body":"Analog I/O Maixduino uses the pwm module of the K210 chip to implement the analogWrite() function. The analogRead() function is temporarily unavailable. In Maixduino, you can configure up to 12 pins of the 48 FPIOs to be Analog Output. analogWrite() Description Writes an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. Syntax analogWrite(pin, value) Parameters pin: the pin to write to. Allowed data types: int. value: the duty cycle: between 0 (always off) and 255 (always on). Allowed data types: int Returns Nothing Notes and Warnings The timer and PWM functions may have an interaction. analogWriteResolution() Description analogWriteResolution() is an extension of the Analog API for the Maixduino. analogWriteResolution() sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) for compatibility with AVR based boards. By setting the write resolution to 12, you can use analogWrite() with values between 0 and 4095 to set the PWM signal without rolling over. Syntax analogWriteResolution(bits) Parameters bits: determines the resolution (in bits) of the values used in the analogWrite() function. The value can range from 1 to 32. Returns Nothing Notes and Warnings Passing the PWM duty cycle may not result in significant accuracy variations. Example Code for Maix Bit, Maix Dock, Maix Go int led1 = 12; // LED_BLUE int led2 = 13; // LED_GREEN | LED_BUILTIN int led3 = 14; // LED_RED void setup() { pinMode(led1, OUTPUT); pinMode(led2, OUTPUT); pinMode(led3, OUTPUT); } void setColor(int red, int green, int blue) { analogWrite(led1, 255-blue); analogWrite(led2, 255-green); analogWrite(led3, 255-red); } void loop() { int i, j; for (i=0, j=255; iExample Code for Maixduino int led1 = 1; // LED_BUILTIN void setup() { pinMode(led1, OUTPUT); } void setColor(int value) { analogWrite(led1, 255-value); } void loop() { int i; for (i=0; i"},"cores/advanced.html":{"url":"cores/advanced.html","title":"Advanced I/O","keywords":"","body":"Advanced I/O tone() Description Generates a square wave of the specified frequency (and 50% duty cycle) on a pin. A duration can be specified, otherwise the wave continues until a call to noTone(). The pin can be connected to a piezo buzzer or other speaker to play tones. Syntax tone(pin, frequency) tone(pin, frequency, duration) Parameters pin: the pin on which to generate the tone frequency: the frequency of the tone in hertz - unsigned int duration: the duration of the tone in milliseconds (optional) - unsigned long Returns Nothing Notes and Warnings If you want to play different pitches on multiple pins, you need to call noTone() on one pin before calling tone() on the next pin. noTone() Description Stops the generation of a square wave triggered by tone(). Has no effect if no tone is being generated. Syntax noTone(pin) Parameters pin: the pin on which to stop generating the tone Returns Nothing Notes and Warnings If you want to play different pitches on multiple pins, you need to call noTone() on one pin before calling tone() on the next pin. "},"cores/constants.html":{"url":"cores/constants.html","title":"Constants","keywords":"","body":"Constants Maixduino uses most of the Arduino constants. You can find more details on the Arduino website. LED #define LED_BUILTIN 13 #define LED_GREEN 13 #define LED_BLUE 12 #define LED_RED 14 "},"cores/digital.html":{"url":"cores/digital.html","title":"Digital I/O","keywords":"","body":"Digital I/O Maixduino supports basic arduino input and output functions. You can use them like other arduino boards. In Maixduino, you can configure up to 32 pins into digital IO using any of the 48 FPIOs. digitalRead() Description Reads the value from a specified digital pin, either HIGH or LOW . Syntax digitalRead(pin) Parameters pin : the number of the digital pin you want to read. Returns HIGH or LOW Notes and Warnings Only pins that are set to the input function by the pinMode() can be read. digitalWrite() Description Write a HIGH or a LOW value to a digital pin. Syntax digitalWrite(pin, value) Parameters pin: the pin number value: HIGH or LOW Returns Nothing Notes and Warnings Only pins that are set to the output function by the pinMode() can be write. pinMode() Description Configures the specified pin to behave either as an input or an output. Syntax pinMode(pin, mode) Parameters pin: the number of the pin whose mode you wish to set. mode: INPUT, OUTPUT, INPUT_PULLDOWN or INPUT_PULLUP. Returns Nothing Notes and Warnings This function must be called to set the pin state before calling digitalRead() or digitalWrite(). Example Code The code makes the digital pin 13 OUTPUT and Toggles it HIGH and LOW. void setup() { pinMode(13, OUTPUT); // sets the digital pin 13 as output } void loop() { digitalWrite(13, HIGH); // sets the digital pin 13 on delay(1000); // waits for a second digitalWrite(13, LOW); // sets the digital pin 13 off delay(1000); // waits for a second } Sets pin 13 to the same value as pin 16, declared as an input. int ledPin = 13; // LED connected to digital pin 13 int inPin = 16; // pushbutton connected to digital pin 16 int val = 0; // variable to store the read value void setup() { pinMode(ledPin, OUTPUT); // sets the digital pin 13 as output pinMode(inPin, INPUT); // sets the digital pin 16 as input } void loop() { val = digitalRead(inPin); // read the input pin digitalWrite(ledPin, val); // sets the LED to the button's value } "},"cores/interrupts.html":{"url":"cores/interrupts.html","title":"Interrupts","keywords":"","body":"Interrupts In Maixduino, you can use up to 32 digital pins of the 48 FPIOs as external interrupts. attachInterrupt() Description Set Digital Pins With Interrupts. Syntax attachInterrupt(pin, ISR, mode) Parameters pin: the pin number ISR: the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine. mode: defines when the interrupt should be triggered. Five constants are predefined as valid values: LOW to trigger the interrupt whenever the pin is low, CHANGE to trigger the interrupt whenever the pin changes value RISING to trigger when the pin goes from low to high, FALLING for when the pin goes from high to low. HIGH to trigger the interrupt whenever the pin is high. Returns Nothing Example Code #include // constants // PIN_KEY_PRESS = KEY0 = 15 // Key volatile byte pressed = HIGH; byte keyState = HIGH; void keyPressChange() { pressed = !pressed; } void setup() { Serial.begin(115200); attachInterrupt(15, keyPressChange, CHANGE); } void loop() { // if the button state has changed: if (pressed != keyState) { keyState = pressed; Serial.print(\"pressed key \"); boolean isPressing = (keyState == LOW); if (isPressing) { Serial.println(\"is pressing\"); } else { Serial.println(\"is pressed\"); } } } Example Code with debounce #include // constants // PIN_KEY_PRESS = KEY0 = 15 // PIN_KEY_DOWN = 16 // PIN_KEY_UP = 17 // Key byte keys[] = {15, 16, 17}; #define NUMKEYS sizeof(keys) volatile byte pressed[NUMKEYS]; byte keyState[NUMKEYS]; byte lastKeyState[NUMKEYS]; // Debounce unsigned long lastDebounceTime[NUMKEYS]; // the last time the output pin was toggled unsigned long debounceDelay = 50; // the debounce time; increase if the output flickers void keyPressChange() { pressed[0] = !pressed[0]; } void keyDownChange() { pressed[1] = !pressed[1]; } void keyUpChange() { pressed[2] = !pressed[2]; } void setup() { for (byte i = 0; i debounceDelay) { // if the button state has changed: if (pressed[i] != keyState[i]) { keyState[i] = pressed[i]; // react only when a key is released if (keyState[i] == HIGH) { switch (i) { case 0: Serial.println(\"pressed\"); break; case 1: Serial.println(\"down\"); break; case 2: Serial.println(\"up\"); break; } } } } lastKeyState[i] = pressed[i]; } } detachInterrupt() Description Turns off the given interrupt. Syntax detachInterrupt(pin) Parameters pin: the pin number of the interrupt to disable Returns Nothing "},"cores/serial.html":{"url":"cores/serial.html","title":"Serial","keywords":"","body":"Serial In Maixduino, there are two types of serial devices, UARTHSClass and UARTClass. The Serial corresponds to the UARTHSClass, and the remaining Serial1, Serial2, and Serial3 are UARTClass. Serial uses the default pin as 4 (RX), 5 (TX). So you can use it in the serial monitor on your computer.The default pins for the other three global serial ports are 6(RX), and 7(TX) (they are connected to the WiFi module),To use them correctly, set different pins for them in begin(). Functions The operation of the serial port is exactly the same as that of Arduino. You can find more information on the Arduino website. if(Serial) available() availableForWrite() begin() end() find() findUntil() flush() parseFloat() parseInt() peek() print() println() read() readBytes() readBytesUntil() readString() readStringUntil() setTimeout() write() serialEvent() Serial port settings Serial.begin(BaudRate, RX , TX ) Notes For platform.io change the serial monitor baudrate in platform.ini. ; serial monitor baudrate monitor_speed = 115200 Serial.println() Description Prints data to the serial port as human-readable ASCII text followed by a carriage return character (ASCII 13, or '\\r') and a newline character (ASCII 10, or '\\n'). This command takes the same forms as Serial.print(). Syntax Serial.println(val) Serial.println(val, format) Parameters Serial: serial port object. val: the value to print. Allowed data types: any data type. format: specifies the number base (for integral data types) or number of decimal places (for floating point types). Returns println() returns the number of bytes written, though reading that number is optional. Data type: size_t. Example Code #include void setup() { Serial.begin(9600); } void loop() { Serial.println(\"Hello world\"); delay(2000); } Serial Monitor in platform.io -- Available ports: --- 1: /dev/ttyUSB0 'USB Debugger' --- 2: /dev/ttyUSB1 'USB Debugger' --- Enter port index or full name: 2 "},"cores/time.html":{"url":"cores/time.html","title":"Time","keywords":"","body":"Time delay() Description Pauses the program for the amount of time (in milliseconds) specified as parameter. (There are 1000 milliseconds in a second.) Syntax delay(ms) Parameters ms: the number of milliseconds to pause (unsigned long) Returns Nothing delayMicroseconds() Description Pauses the program for the amount of time (in microseconds) specified as parameter. There are a thousand microseconds in a millisecond, and a million microseconds in a second. Syntax delayMicroseconds(us) Parameters us: the number of microseconds to pause (unsigned int) Returns Nothing micros() Description Returns the number of microseconds since the Arduino board began running the current program. Syntax time = micros() Parameters Nothing Returns Returns the number of microseconds since the Maixduino board began running the current program.(unsigned long) millis() Description Returns the number of milliseconds passed since the Maixduino board began running the current program. This number will overflow (go back to zero), after approximately 50 days. Syntax time = millis() Parameters None Returns Number of milliseconds passed since the program started (unsigned long) "},"libs/msa300.html":{"url":"libs/msa300.html","title":"MSA300 Accelerometer","keywords":"","body":"MSA300 - Digital Triaxial Accelerometer MSA300 is a triaxial, low-g accelerometer with I2C/SPI digital output for sensitivity consumer applications Datasheet MSA300-V1.0-ENG getAcceleration() Description getAcceleration() returns the acceleration. Syntax getAcceleration() Returns acc_t Acceleration struct containing accelarations of each axis in m/s^2 Example Code see example msa basic #include #include // This is the length of the string that will be created // included minus and decimal point const signed char formattedStringLength = 11; // The number of digits after the deimal point to print const unsigned char numVarsAfterDecimal = 6; acc_t data; MSA300 msa; static char outstr[11]; char * formatValue(float value) { dtostrf(value, formattedStringLength, numVarsAfterDecimal, outstr); return outstr; } void setup() { Serial.begin(115200); Wire.begin(); msa.begin(); } void loop() { data = msa.getAcceleration(); Serial.printf(\"Xa:%s \", formatValue(data.x)); Serial.printf(\"Ya:%s \", formatValue(data.y)); Serial.printf(\"Za:%s\", formatValue(data.z)); Serial.println(); delay(100); } "},"libs/ns2009.html":{"url":"libs/ns2009.html","title":"NS2009 Touchscreen","keywords":"","body":"NS2009 - Touchscreen driver NS2009 is a touchscreen driver getStatus() Description getStatus() returns the touch status, the default is TOUCH_NONE. Syntax getStatus() Returns int status enum containing TOUCH_NONE, TOUCH_BEGIN, TOUCH_MOVE or TOUCH_END Example Code see example drawline #include #include \"touchscreen.h\" SPIClass spi0(SPI0); // MUST be SPI0 for Maix series on board LCD Sipeed_ST7789 lcd(320, 240, spi0); TouchScreen touchscreen; int key = KEY0; int touchscreen_status = 0; int touchscreen_x = 0; int touchscreen_y = 0; int status_last = TOUCH_NONE; int x_last = 0; int y_last = 0; bool draw = false; void setup() { pinMode(key, INPUT); lcd.begin(15000000, COLOR_RED); touchscreen.begin(); touchscreen.calibrate(320, 240); } void loop() { touchscreen.read(); touchscreen_status = touchscreen.getStatus(); touchscreen_x = touchscreen.getX(); touchscreen_y = touchscreen.getY(); if (draw) { lcd.writeLine(x_last,y_last,touchscreen_x,touchscreen_y,COLOR_WHITE); } if (status_last != touchscreen_status) { draw = (touchscreen_status == TOUCH_BEGIN || touchscreen_status == TOUCH_MOVE); status_last = touchscreen_status; } x_last = touchscreen_x; y_last = touchscreen_y; if (digitalRead(key) == LOW) { lcd.fillScreen(COLOR_BLACK); } } "},"libs/sipeed_ov2640.html":{"url":"libs/sipeed_ov2640.html","title":"Sipeed_OV2640 Camera","keywords":"","body":"OV2640 - Camera The OV2640 Camera chip is a low voltage CMOS imagesensor that provides the full functionality of a single-chip UXGA (1632x1232 - 2 MegaPixel) camera and image processor. Datasheet OV2640-DATASHEET snapshot() Description snapshot() returns an image. Syntax snapshot() Returns uint8_t* pixels - if pixels format is RGB565: return RGB565 pixels with every uint16_t one pixel, e.g. RED: 0xF800 Example Code see example selfie #include #include SPIClass spi0(SPI0); // MUST be SPI0 for Maix series on board LCD Sipeed_ST7789 lcd(320, 240, spi0); Sipeed_OV2640 camera(FRAMESIZE_QVGA, PIXFORMAT_RGB565); void setup() { Serial.begin(115200); lcd.begin(15000000, COLOR_RED); // lcd.invertDisplay(true); // comment this out when camera is on the backside Serial.print(\"camera init \"); if(!camera.begin()) Serial.println(\"failed\"); else Serial.println(\"success\"); camera.run(true); } void loop() { uint8_t* img = camera.snapshot(); if (img == nullptr || img == 0) Serial.println(\"snap failed\"); else lcd.drawImage(0, 0, camera.width(), camera.height(), (uint16_t*)img); } "},"libs/sipeed_st7789.html":{"url":"libs/sipeed_st7789.html","title":"Sipeed_ST7789 Display","keywords":"","body":"ST7789V - LCD The ST7789V is a single-chip controller/driver for 262K-color, graphic type TFT-LCD. Datasheet ST7789V_SPEC_V0.1 Constants: #define COLOR_BLACK 0x0000 #define COLOR_NAVY 0x000F #define COLOR_DARKGREEN 0x03E0 #define COLOR_DARKCYAN 0x03EF #define COLOR_MAROON 0x7800 #define COLOR_PURPLE 0x780F #define COLOR_OLIVE 0x7BE0 #define COLOR_LIGHTGREY 0xC618 #define COLOR_DARKGREY 0x7BEF #define COLOR_BLUE 0x001F #define COLOR_GREEN 0x07E0 #define COLOR_CYAN 0x07FF #define COLOR_RED 0xF800 #define COLOR_MAGENTA 0xF81F #define COLOR_YELLOW 0xFFE0 #define COLOR_WHITE 0xFFFF #define COLOR_ORANGE 0xFD20 #define COLOR_GREENYELLOW 0xAFE5 #define COLOR_PINK 0xF81F Example Code see examples basic display "},"libs/spi.html":{"url":"libs/spi.html","title":"SPI","keywords":"","body":"SPI "},"contribute/":{"url":"contribute/","title":"Contribute","keywords":"","body":"Contribute to the project Since this is an open source project, everyone is welcome to join in and improve Maixduino. For a better readable documentation and code we need a code convention (including format, style, etc.) The following documents describe the coding convention for both the documentation and code: Documentation convention Code convention "},"contribute/doc_convention.html":{"url":"contribute/doc_convention.html","title":"Documentation convention","keywords":"","body":"Documentation Convention Documents are built using gitbook and written in simple and efficient Markdown The documentation source code is hosted on GitHub Markdown syntax If you've never used the basic syntax of Markdown, please take half an hour to learn. We recommend the GitHub tutorial: GitHub Markdown Tutorial In this article, we need to pay attention to the following points: The syntax tags of the title class must be separated by spaces. A blank line is required between the headline and the body, such as: ## This is a secondary title * This is list item 1 * This is list item 2 The following example is not correct, it may cause the parser to parse the file with errors. ##This is a secondary title *This is list item 1 *This is list item 2 All pages have only one top level title Because the need to automatically generate a directory, mainly to ensure that the automatically generated directory is correct. Write each page like this Page title/top level title ======= (There is at least three equals here) (At least one more blank line is required, 2 lines are recommended) ## Secondary title 1 (You cannot use a first-level title here, and you cannot use a ##. You don't need to write a serial number, it will automatically generate a serial number.) ( Skip a line ) text (at least one line) ### Three-level title (similar to the second-level title, it does not need to be written, it will be generated automatically) text ## Secondary title 2 text Link Due to the large number of pages and the need to link resources such as images, relative paths are used when writing links. The directory structure is as follows: assets/ (put public resource files) | ----pic000.png en/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ------ pic.png | ---- get_hardware.md zh/ If you want to show the images in get_hardware.md, put the image in the assets folder, then use the following code to reference the image: ![pic](assets/pic.png) ![pic](../../assets/pic000.png) Chinese and English mixed When writing Chinese documents, the Chinese characters should be separated by spaces as much as possible. Punctuation should use full-width symbols as much as possible. Mainly to make it stand out and make the document more elegant. For example, the following comparison: The `setup` function is called when a sketch starts. Use it to initialize variables, pin modes, start using libraries, etc. The setup function is called when a sketch starts. Use it to initialize variables, pin modes, start using libraries, etc. The setup function is called when a sketch starts. Use it to initialize variables, pin modes, start using libraries, etc. The setup function is called when a sketch starts. Use it to initialize variables, pin modes, start using libraries, etc. Directory and file name The generated document directory is edited in the corresponding language folder SUMMARY.md The source document folder should be a function module corresponding to a folder, and the resource file (picture) is placed in the assets folder directory of the current path of the corresponding md document, which is more convenient when adding, deleting, and modifying. assets/ (put public resource files) en/ | ----- get_started/ | ---- assets/ (put the resource file common to the md file in the get_started directory) | ---- get_hardware.md zh/ The file name is not limited to README.md, other file names are named with lowercase + underscore, such as get_hardware.md Catalog and links Try to guide readers to use the directory, and use the jump link in the text with caution. If the link jumps in a mess, it will cause the document to look messy and it will be difficult to read. Chinese and English (multi-language) page file directory structure and file name are the same Since there are multiple language switching options in the last generated page, clicking the switch will directly access the same path of the corresponding language, so the Chinese and English directory structure and file name must be the same. For example, English is accessing en/get_started/blink.md. After clicking the button for language switching, it will automatically access zh/get_started/blink.md. If this file does not exist, it will report a 404 error! Module Document Content Need to include a module introduction in the file header Need to explain the constructor, function, constant, etc. Explain that you can't be lazy. Simply translate the function name again. You need to explain the function of the function, the range of parameters, and the point of attention Multi-version management In addition to the Chinese and English (multi-language) support (not automatic translation, manual modification), the document also has multi-version management. Each version is a branch with requirements for the branch name, which are: master branch is the main branch dev branch for development branch Other published historical versions start with a lowercase v, such as creating a branch called v1.2 After creating a new branch, you need to modify the version link in book.json in the directory of each language version, otherwise the reader can't find the entry. You can preview it locally under the newly created branch (see the root directory README.md for the preview method). Note that the previewed page is the current branch. If you want to preview other branches locally, you need to switch to other points before previewing. Just fine. After confirming that the error is modified, push the branch to the remote (github), the automatic build system will be automatically built and published to the pages branch, and the effect will be seen when the access URL is built. "},"contribute/code_convention.html":{"url":"contribute/code_convention.html","title":"Code convention","keywords":"","body":"Code Convention "}}